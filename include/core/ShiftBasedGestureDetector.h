#ifndef SHIFT_BASED_GESTURE_DETECTOR_H
#define SHIFT_BASED_GESTURE_DETECTOR_H

#include "IGestureDetector.h"
#include "InputStateProcessor.h"
#include "InputSystemConfiguration.h"
#include "ControlMessage.h"
#include "InputEvent.h"
#include <vector>
#include <cstdint>

/**
 * @file ShiftBasedGestureDetector.h
 * @brief SHIFT-based parameter lock gesture detector with bank-aware controls
 * 
 * Implements Phase 2 of the parameter lock system using deterministic SHIFT-based
 * gesture detection. Replaces timing-based parameter lock detection with explicit
 * SHIFT button press patterns for reliable, bank-aware parameter control.
 * 
 * Key Features:
 * - Deterministic SHIFT + button press → parameter lock entry
 * - Bank-aware control mapping (left triggers right, right triggers left)
 * - 64-bit state encoding for parameter lock management
 * - Limited control functions per bank (4 controls each)
 * - BUTTON_PRESS of lock key → parameter lock exit
 * 
 * Architecture Integration:
 * This implements IGestureDetector interface for backward compatibility with
 * existing InputController while providing the enhanced SHIFT-based functionality.
 * It works alongside InputStateProcessor for complete input handling.
 */
class ShiftBasedGestureDetector : public IGestureDetector {
public:
    /**
     * @brief Control parameter types for parameter adjustment messages
     */
    enum class ParameterType : uint8_t {
        NOTE_MINUS = 0,    ///< Decrease note value
        NOTE_PLUS = 1,     ///< Increase note value
        VELOCITY_MINUS = 2, ///< Decrease velocity
        VELOCITY_PLUS = 3   ///< Increase velocity
    };
    
    /**
     * @brief Bank configuration for button layout
     */
    enum class BankId : uint8_t {
        LEFT_BANK = 0,     ///< Left bank (buttons 1-4, qwer, asdf, zxcv)
        RIGHT_BANK = 1     ///< Right bank (buttons 5678, tyui, ghjk, bnm,)
    };
    
    /**
     * @brief Constructor with state processor integration
     * 
     * @param stateProcessor Shared InputStateProcessor for state management
     */
    explicit ShiftBasedGestureDetector(InputStateProcessor* stateProcessor = nullptr);
    
    /**
     * @brief Virtual destructor for proper cleanup
     */
    virtual ~ShiftBasedGestureDetector() = default;
    
    // IGestureDetector interface implementation
    
    /**
     * @brief Process input event and generate control messages
     * 
     * Processes SHIFT-based gesture detection:
     * 1. SHIFT_BUTTON_PRESS → Enter parameter lock mode with bank awareness
     * 2. BUTTON_PRESS during parameter lock → Generate parameter adjustment or exit
     * 3. Regular BUTTON_PRESS → Generate step toggle (when not in parameter lock)
     * 
     * @param inputEvent Raw input event from input layer
     * @param controlMessages Output vector to receive generated control messages
     * @return Number of control messages generated
     */
    uint8_t processInputEvent(const InputEvent& inputEvent, 
                             std::vector<ControlMessage::Message>& controlMessages) override;
    
    /**
     * @brief Update gesture detection state based on time passage
     * 
     * For SHIFT-based detection, timing updates are minimal since we use
     * explicit SHIFT press patterns rather than timing-based detection.
     * 
     * @param currentTime Current time in milliseconds
     * @param controlMessages Output vector for any time-triggered messages
     * @return Number of control messages generated by timeout events
     */
    uint8_t updateTiming(uint32_t currentTime,
                        std::vector<ControlMessage::Message>& controlMessages) override;
    
    /**
     * @brief Reset all gesture detection state
     * 
     * Clears parameter lock state and resets all button tracking.
     */
    void reset() override;
    
    /**
     * @brief Get current button states tracked by gesture detector
     * 
     * @param buttonStates Output array for button states (true = pressed)
     * @param maxButtons Size of the buttonStates array
     * @return Number of buttons for which state was returned
     */
    uint8_t getCurrentButtonStates(bool* buttonStates, uint8_t maxButtons) const override;
    
    /**
     * @brief Check if gesture detector is currently in parameter lock mode
     * 
     * @return true if in parameter lock mode
     */
    bool isInParameterLockMode() const override;
    
    /**
     * @brief Update gesture detector configuration
     * 
     * @param config New configuration to apply
     */
    void setConfiguration(const struct InputSystemConfiguration& config) override;

private:
    /**
     * @brief Bank-aware button mapping configuration
     */
    struct BankMapping {
        // Left bank control buttons (simulation keyboard mapping)
        static constexpr uint8_t LEFT_NOTE_MINUS = 25;   // 'z' key
        static constexpr uint8_t LEFT_NOTE_PLUS = 0;     // 'a' key  
        static constexpr uint8_t LEFT_VEL_MINUS = 26;    // 'x' key
        static constexpr uint8_t LEFT_VEL_PLUS = 1;      // 's' key
        
        // Right bank control buttons (simulation keyboard mapping)
        static constexpr uint8_t RIGHT_NOTE_MINUS = 30;  // 'b' key
        static constexpr uint8_t RIGHT_NOTE_PLUS = 6;    // 'g' key
        static constexpr uint8_t RIGHT_VEL_MINUS = 31;   // 'n' key
        static constexpr uint8_t RIGHT_VEL_PLUS = 7;     // 'h' key
        
        /**
         * @brief Check if button is in left bank (triggers right bank controls)
         * 
         * Left bank includes: 1-4, qwer, asdf, zxcv
         * When pressed with SHIFT, enables right bank controls
         */
        static bool isLeftBankButton(uint8_t buttonId);
        
        /**
         * @brief Check if button is in right bank (triggers left bank controls)
         * 
         * Right bank includes: 5678, tyui, ghjk, bnm,
         * When pressed with SHIFT, enables left bank controls  
         */
        static bool isRightBankButton(uint8_t buttonId);
        
        /**
         * @brief Get parameter adjustment from control button press
         * 
         * Maps control button to parameter type and delta based on active bank.
         * 
         * @param buttonId Control button pressed
         * @param activeBankId Which bank controls are active
         * @param paramType Output parameter type
         * @param delta Output adjustment delta (-1 or +1)
         * @return true if button is a valid control for the active bank
         */
        static bool getParameterAdjustment(uint8_t buttonId, BankId activeBankId,
                                         ParameterType& paramType, int8_t& delta);
    };
    
    // State management using 64-bit encoding
    InputState currentState_;           ///< Current 64-bit input state
    InputStateProcessor* stateProcessor_; ///< Optional shared state processor
    InputSystemConfiguration config_;   ///< Current system configuration
    
    // Parameter lock state tracking
    bool parameterLockActive_;          ///< Current parameter lock status
    uint8_t lockButtonId_;              ///< Button ID that triggered parameter lock
    BankId activeBankId_;               ///< Which bank triggered the parameter lock
    
    // Button state tracking for gesture detection
    uint32_t buttonStates_;             ///< Current button press states (32-bit mask)
    
    /**
     * @brief Process SHIFT + button press for parameter lock entry
     * 
     * Handles SHIFT_BUTTON_PRESS events to enter parameter lock mode
     * with proper bank detection and state encoding.
     * 
     * @param inputEvent SHIFT button press event
     * @param controlMessages Output vector for control messages
     * @return Number of messages generated
     */
    uint8_t processShiftButtonPress(const InputEvent& inputEvent,
                                   std::vector<ControlMessage::Message>& controlMessages);
    
    /**
     * @brief Process regular button press during parameter lock
     * 
     * Handles button presses when parameter lock is active:
     * - Control buttons → Generate ADJUST_PARAMETER messages
     * - Lock button → Exit parameter lock mode
     * - Other buttons → Ignored
     * 
     * @param inputEvent Button press event
     * @param controlMessages Output vector for control messages
     * @return Number of messages generated
     */
    uint8_t processParameterLockButton(const InputEvent& inputEvent,
                                      std::vector<ControlMessage::Message>& controlMessages);
    
    /**
     * @brief Process regular button press for step toggle
     * 
     * Handles normal button presses when not in parameter lock mode.
     * Generates TOGGLE_STEP messages for sequencer step control.
     * 
     * @param inputEvent Button press event
     * @param controlMessages Output vector for control messages
     * @return Number of messages generated
     */
    uint8_t processStepToggle(const InputEvent& inputEvent,
                             std::vector<ControlMessage::Message>& controlMessages);
    
    /**
     * @brief Exit parameter lock mode
     * 
     * Clears parameter lock state and updates 64-bit state encoding.
     * 
     * @param controlMessages Output vector for exit message
     * @return Number of messages generated (0 or 1)
     */
    uint8_t exitParameterLock(std::vector<ControlMessage::Message>& controlMessages);
    
    /**
     * @brief Update button state tracking
     * 
     * Maintains button press state for gesture detection.
     * Updates both local tracking and 64-bit state encoding.
     * 
     * @param buttonId Button to update
     * @param pressed New press state
     */
    void updateButtonState(uint8_t buttonId, bool pressed);
    
    /**
     * @brief Convert button ID to track/step coordinates
     * 
     * Maps linear button ID to track and step numbers for sequencer.
     * Assumes 4x8 grid layout (4 tracks, 8 steps).
     * 
     * @param buttonId Linear button index (0-31)
     * @param track Output track number (0-3)
     * @param step Output step number (0-7)
     */
    void buttonToTrackStep(uint8_t buttonId, uint8_t& track, uint8_t& step) const;
    
    /**
     * @brief Generate control message with proper timestamp
     * 
     * Helper to create control messages with current timestamp.
     * 
     * @param type Message type
     * @param param1 First parameter
     * @param param2 Second parameter
     * @return Configured control message
     */
    ControlMessage::Message createMessage(ControlMessage::Type type, 
                                        uint32_t param1 = 0, uint32_t param2 = 0) const;
};

#endif // SHIFT_BASED_GESTURE_DETECTOR_H